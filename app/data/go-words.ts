export const GO_WORDS = [
  `package main↵import "fmt"↵func fib(n int) int {→a,b:=0,1;→for i:=0;i<n;i++{→a,b=b,a+b}→return a}↵func main(){→for i:=0;i<10;i++{→fmt.Printf("fib(%d)=%d\\n",i,fib(i))}→s:="Copilot is helpful!";→for i:=len(s)-1;i>=0;i--{→fmt.Printf("%c",s[i])}→fmt.Println()}`,
  `package main↵import "fmt"↵func fact(n int) int {→if n==0{return 1}→return n*fact(n-1)}↵func main(){→for i:=0;i<7;i++{→fmt.Println(fact(i))}→words:=[]string{"quick","brown","fox"};→for _,w:=range words{→fmt.Println(len(w))}}`,
  `package main↵import ("fmt";"math/rand";"sort")↵func main(){→lst:=make([]int,20);→for i:=range lst{→lst[i]=rand.Intn(100)}→fmt.Println(lst);→sort.Ints(lst);→fmt.Println(lst);→for _,v:=range lst{→if v%2==0{→fmt.Print(v," ")}}→fmt.Println()}`,
  `package main↵import "fmt"↵func palindrome(s string)bool{→n:=len(s);→for i:=0;i<n/2;i++{→if s[i]!=s[n-1-i]{→return false}}→return true}↵func main(){→words:=[]string{"level","world","radar"};→for _,w:=range words{→if palindrome(w){→fmt.Println(w)}}}`,
  `package main↵import ("fmt";"strings")↵func main(){→s:="The rain in Spain";→fmt.Println(strings.Count(s,"ain"));→fmt.Println(strings.ReplaceAll(s,"ain","***"));→fmt.Println(strings.Split(s," "));→fmt.Println(strings.HasPrefix(s,"The"));→fmt.Println(strings.Contains(s,"Spain"))}`,
  `package main↵import "fmt"↵func gcd(a,b int)int{→for b!=0{→a,b=b,a%b}→return a}↵func lcm(a,b int)int{→return a*b/gcd(a,b)}↵func main(){→fmt.Println(gcd(48,18));→fmt.Println(lcm(12,15));→for i:=1;i<=10;i++{→fmt.Print(gcd(i,100)," ")}→fmt.Println()}`,
  `package main↵import "fmt"↵func isPrime(n int)bool{→if n<2{return false}→for i:=2;i*i<=n;i++{→if n%i==0{return false}}→return true}↵func main(){→for i:=2;i<30;i++{→if isPrime(i){→fmt.Print(i," ")}}→fmt.Println()}`,
  `package main↵import "fmt"↵func reverseWords(s string)string{→words:=strings.Fields(s);→for i,j:=0,len(words)-1;i<j;i,j=i+1,j-1{→words[i],words[j]=words[j],words[i]}→return strings.Join(words," ")}↵func main(){→fmt.Println(reverseWords("hello world from go"))}`,
  `package main↵import ("fmt";"os")↵func main(){→fmt.Println(os.Getwd());→fmt.Println(os.Args);→fmt.Println(os.TempDir());→fmt.Println(os.Getenv("HOME"));→fmt.Println(os.PathSeparator);→fmt.Println(os.PathListSeparator)}`,
  `package main↵import "fmt"↵func squares(n int)[]int{→res:=make([]int,n);→for i:=0;i<n;i++{→res[i]=i*i}→return res}↵func main(){→fmt.Println(squares(10));→sum:=0;→for _,v:=range squares(5){→sum+=v}→fmt.Println(sum)}`,
  `package main↵import ("fmt";"time")↵func main(){→start:=time.Now();→time.Sleep(100*time.Millisecond);→fmt.Printf("Elapsed: %.3fs\\n",time.Since(start).Seconds());→fmt.Println(time.Now().Format("15:04:05"))}`,
  `package main↵import "fmt"↵func unique(lst []int)[]int{→m:=map[int]bool{};→res:=[]int{};→for _,v:=range lst{→if !m[v]{→m[v]=true;→res=append(res,v)}}→return res}↵func main(){→fmt.Println(unique([]int{1,2,2,3,4,4,5}))}`,
  `package main↵import ("fmt";"encoding/json")↵func main(){→data:=map[string]interface{}{"a":1,"b":2,"c":[]int{3,4,5}};→js,_:=json.Marshal(data);→fmt.Println(string(js));→var m map[string]interface{};→json.Unmarshal(js,&m);→fmt.Println(m)}`,
  `package main↵import "fmt"↵func flatten(nested [][]int)[]int{→res:=[]int{};→for _,sub:=range nested{→res=append(res,sub...)}→return res}↵func main(){→fmt.Println(flatten([][]int{{1,2},{3,4,5},{6}}))}`,
  `package main↵import ("fmt";"math")↵func main(){→for i:=0;i<10;i++{→fmt.Printf("%.2f ",math.Sqrt(float64(i)))}→fmt.Println();→fmt.Println(math.Pi,math.E)}`,
  `package main↵import "fmt"↵func transpose(m [][]int)[][]int{→if len(m)==0{return [][]int{}}→res:=make([][]int,len(m[0]));→for i:=range res{→res[i]=make([]int,len(m))}→for i:=range m{→for j:=range m[0]{→res[j][i]=m[i][j]}}→return res}↵func main(){→fmt.Println(transpose([][]int{{1,2,3},{4,5,6},{7,8,9}}))}`,
  `package main↵import "fmt"↵func merge(a,b []int)[]int{→res:=append(a,b...);→sort.Ints(res);→return res}↵func main(){→fmt.Println(merge([]int{1,3,5},[]int{2,4,6}))}`,
  `package main↵import "fmt"↵func allEven(lst []int)bool{→for _,v:=range lst{→if v%2!=0{return false}}→return true}↵func main(){→fmt.Println(allEven([]int{2,4,6,8}));→fmt.Println(allEven([]int{1,2,3}))}`,
  `package main↵import "fmt"↵func chunk(lst []int,n int)[][]int{→var res [][]int;→for i:=0;i<len(lst);i+=n{→end:=i+n;→if end>len(lst){→end=len(lst)}→res=append(res,lst[i:end])}→return res}↵func main(){→fmt.Println(chunk([]int{1,2,3,4,5,6,7,8,9},3))}`,
  `package main↵import ("fmt";"crypto/sha256")↵func main(){→s:="hello world";→h:=sha256.Sum256([]byte(s));→fmt.Printf("%x\\n",h);}`,
  `package main↵import ("fmt";"math/rand")↵func main(){→rand.Seed(42);→for i:=0;i<5;i++{→fmt.Printf("%.3f ",rand.Float64())}→fmt.Println();→for i:=0;i<5;i++{→fmt.Print(rand.Intn(10)," ")}→fmt.Println()}`,
  `package main↵import "fmt"↵func isAnagram(a,b string)bool{→if len(a)!=len(b){→return false}→ma,mb:=map[rune]int{},map[rune]int{};→for _,c:=range a{→ma[c]++}→for _,c:=range b{→mb[c]++}→for k,v:=range ma{→if mb[k]!=v{→return false}}→return true}↵func main(){→fmt.Println(isAnagram("listen","silent"))}`,
  `package main↵import ("fmt";"sort")↵func main(){→lst:=[]int{5,1,3,7,2};→sort.Ints(lst);→fmt.Println(lst);→fmt.Println(sort.SearchInts(lst,3));}`,
  `package main↵import "fmt"↵func countVowels(s string)int{→c:=0;→for _,ch:=range s{→if strings.ContainsRune("aeiouAEIOU",ch){→c++}}→return c}↵func main(){→fmt.Println(countVowels("Copilot"));→fmt.Println(countVowels("Python"))}`,
  `package main↵import ("fmt";"container/heap")↵type IntHeap []int↵func (h IntHeap)Len()int{→return len(h)}↵func (h IntHeap)Less(i,j int)bool{→return h[i]<h[j]}↵func (h IntHeap)Swap(i,j int){→h[i],h[j]=h[j],h[i]}↵func (h *IntHeap)Push(x interface{}){→*h=append(*h,x.(int))}↵func (h *IntHeap)Pop()interface{}{→old:=*h;→n:=len(old);→x:=old[n-1];→*h=old[0:n-1];→return x}↵func main(){→h:=&IntHeap{5,1,3,7,2};→heap.Init(h);→fmt.Println(heap.Pop(h))}`,
  `package main↵import "fmt"↵func runLengthEncode(s string)[]struct{c rune;count int}{→if len(s)==0{return nil}→res:=[]struct{c rune;count int}{}→prev,count:=rune(s[0]),1→for _,c:=range s[1:]{→if c==prev{→count++}else{→res=append(res,struct{c rune;count int}{prev,count});→prev=c;→count=1}}→res=append(res,struct{c rune;count int}{prev,count});→return res}↵func main(){→fmt.Println(runLengthEncode("aaabbcaaa"))}`,
  `package main↵import ("fmt";"container/list")↵func main(){→l:=list.New();→l.PushBack(1);→l.PushFront(0);→for e:=l.Front();e!=nil;e=e.Next(){→fmt.Print(e.Value," ")}→fmt.Println()}`,
  `package main↵import "fmt"↵func pascal(n int)[][]int{→res:=[][]int{{1}};→for i:=1;i<n;i++{→row:=make([]int,i+1);→row[0],row[i]=1,1;→for j:=1;j<i;j++{→row[j]=res[i-1][j-1]+res[i-1][j]}→res=append(res,row)}→return res}↵func main(){→for _,row:=range pascal(5){→fmt.Println(row)}}`,
  `package main↵import ("fmt";"os")↵func main(){→f,err:=os.Create("test.txt");→if err!=nil{→panic(err)}→defer f.Close();→f.WriteString("hello\\n");→data,err:=os.ReadFile("test.txt");→if err!=nil{→panic(err)}→fmt.Print(string(data))}`,
  `package main↵import "fmt"↵func isPalindromeNum(n int)bool{→s:=fmt.Sprintf("%d",n);→for i:=0;i<len(s)/2;i++{→if s[i]!=s[len(s)-1-i]{→return false}}→return true}↵func main(){→for i:=100;i<200;i++{→if isPalindromeNum(i){→fmt.Print(i," ")}}→fmt.Println()}`,
  `package main↵import ("fmt";"github.com/google/uuid")↵func main(){→u:=uuid.New();→fmt.Println(u);→fmt.Println(u.String())}`,
  `package main↵import "fmt"↵func groupByLen(words []string)map[int][]string{→d:=map[int][]string{};→for _,w:=range words{→l:=len(w);→d[l]=append(d[l],w)}→return d}↵func main(){→words:=[]string{"the","quick","brown","fox"};→fmt.Println(groupByLen(words))}`,
  `package main↵import ("fmt";"time")↵func main(){→fmt.Println(time.Now().Year());→fmt.Println(time.Now().Month());→fmt.Println(time.Now().Day());→fmt.Println(time.Now().Weekday())}`,
  `package main↵import "fmt"↵func isSorted(lst []int)bool{→for i:=0;i<len(lst)-1;i++{→if lst[i]>lst[i+1]{→return false}}→return true}↵func main(){→fmt.Println(isSorted([]int{1,2,3,4}));→fmt.Println(isSorted([]int{4,3,2,1}))}`,
  `package main↵import ("fmt";"os";"io/ioutil")↵func main(){→ioutil.WriteFile("test2.txt",[]byte("hello"),0644);→data,_:=ioutil.ReadFile("test2.txt");→fmt.Println(string(data));→os.Remove("test2.txt")}`,
  `package main↵import "fmt"↵func toBase(n,b int)string{→digits:="0123456789ABCDEF";→res:="";→if n==0{return "0"}→for n>0{→res=string(digits[n%b])+res;→n/=b}→return res}↵func main(){→fmt.Println(toBase(255,2));→fmt.Println(toBase(255,16))}`,
  `package main↵import ("fmt";"archive/zip";"os")↵func main(){→f,_:=os.Create("test.zip");→w:=zip.NewWriter(f);→fw,_:=w.Create("test.txt");→fw.Write([]byte("hello"));→w.Close();→f.Close();→r,_:=zip.OpenReader("test.zip");→for _,f:=range r.File{→fmt.Println(f.Name)}}`,
  `package main↵import "fmt"↵func freq(s string)map[rune]int{→d:=map[rune]int{};→for _,c:=range s{→d[c]++}→return d}↵func main(){→fmt.Println(freq("abracadabra"));→fmt.Println(freq("mississippi"))}`,
  `package main↵import ("fmt";"net")↵func main(){→h,_:=os.Hostname();→fmt.Println(h);→addrs,_:=net.LookupHost("localhost");→fmt.Println(addrs)}`,
  `package main↵import "fmt"↵func spiral(n int)[][]int{→a:=make([][]int,n);→for i:=range a{→a[i]=make([]int,n)}→x,y,dx,dy:=0,0,0,1;→for i:=1;i<=n*n;i++{→a[x][y]=i;→if a[(x+dx)%n][(y+dy)%n]!=0{→dx,dy=dy,-dx}→x+=dx;→y+=dy}→return a}↵func main(){→for _,row:=range spiral(5){→fmt.Println(row)}}`,
  `package main↵import ("fmt";"io/ioutil")↵func main(){→f,_:=ioutil.TempFile("", "tmp");→f.Write([]byte("hello world"));→fmt.Println(f.Name());→f.Close()}`,
  `package main↵import "fmt"↵func isSubsequence(a,b string)bool{→j:=0;→for i:=0;i<len(b)&&j<len(a);i++{→if a[j]==b[i]{→j++}}→return j==len(a)}↵func main(){→fmt.Println(isSubsequence("abc","aabbcc"));→fmt.Println(isSubsequence("ace","abcde"))}`,
  `package main↵import ("fmt";"encoding/csv";"os")↵func main(){→f,_:=os.Create("test.csv");→w:=csv.NewWriter(f);→w.Write([]string{"a","b","c"});→w.WriteAll([][]string{{"1","2","3"},{"4","5","6"}});→w.Flush();→f.Close();→f2,_:=os.Open("test.csv");→r:=csv.NewReader(f2);→rows,_:=r.ReadAll();→fmt.Println(rows)}`,
  `package main↵import ("fmt";"strings")↵func main(){→s:="The quick brown fox jumps over the lazy dog";→words:=strings.Fields(s);→sort.Slice(words,func(i,j int)bool{return len(words[i])<len(words[j])});→fmt.Println(words)}`,
  `package main↵import ("fmt";"os")↵func main(){→fmt.Println(os.Getenv("PATH"));→fmt.Println(os.Getenv("USER"));→fmt.Println(os.Getenv("SHELL"))}`,
  `package main↵import ("fmt";"sort")↵func main(){→words:=[]string{"banana","apple","cherry"};→sort.Strings(words);→fmt.Println(words)}`,
  `package main↵import ("fmt";"math")↵func main(){→fmt.Println(math.Pow(2,10));→fmt.Println(math.Log(100));→fmt.Println(math.Sin(math.Pi/2))}`,
  `package main↵import ↵→"fmt"↵→"math"↵↵func main() {↵→primes := []int{}↵→for i := 2; i < 100; i++ {↵→→isPrime := true↵→→for j := 2; j*j <= i; j++ {↵→→→if i%j == 0 { isPrime = false; break }↵→→}↵→→if isPrime { primes = append(primes, i) }↵→}↵→fmt.Println("Primes under 100:", primes)↵→sum := 0↵→for _, v := range primes { sum += v }↵→fmt.Println("Sum:", sum)↵}`,
  `package main↵import ↵→"fmt"↵→"strings"↵↵func wordCount(s string) map[string]int {↵→words := strings.Fields(s)↵→counts := map[string]int{}↵→for _, w := range words { counts[w]++ }↵→return counts↵}↵func main() {↵→text := "go is expressive concise clean and efficient go is fun"↵→counts := wordCount(text)↵→for k, v := range counts { fmt.Printf("%s: %d\\n", k, v) }↵→fmt.Println("Unique words:", len(counts))↵}`,
  `package main↵import ↵→"fmt"↵→"sort"↵↵type Person struct {↵→Name string↵→Age int↵}↵func main() {↵→people := []Person{↵→→{"Alice", 30}, {"Bob", 25}, {"Charlie", 35}, {"Diana", 28},↵→→{"Eve", 22}, {"Frank", 40}, {"Grace", 27}, {"Heidi", 33},↵→}↵→sort.Slice(people, func(i, j int) bool { return people[i].Age < people[j].Age })↵→for _, p := range people { fmt.Printf("%s is %d years old\\n", p.Name, p.Age) }↵→avg := 0↵→for _, p := range people { avg += p.Age }↵→fmt.Println("Average age:", avg/len(people))↵}`,
];
