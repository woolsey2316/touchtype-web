export const RUST_WORDS = [
  `fn fib(n: u32) -> u32 {↵→let (mut a, mut b) = (0, 1);↵→for _ in 0..n {↵→→let tmp = a;↵→→a = b;↵→→b = tmp + b;↵→}↵→a↵}↵fn main() {↵→for i in 0..10 {↵→→println!("fib({})={}", i, fib(i));↵→}↵→let s = "Copilot is helpful!";↵→println!("{}", s.chars().rev().collect::<String>());↵→let d: Vec<_> = (0..5).map(|x| (x, x*x)).collect();↵→println!("{:?}", d);↵}`,
  `fn fact(n: u32) -> u32 {↵→if n == 0 { 1 } else { n * fact(n - 1) }↵}↵fn main() {↵→for i in 0..7 {↵→→println!("{}", fact(i));↵→}↵→let words = vec!["quick", "brown", "fox"];↵→let mut sorted = words.clone();↵→sorted.sort_by_key(|w| w.len());↵→println!("{:?}", sorted);↵}`,
  `use rand::Rng;↵fn main() {↵→let mut rng = rand::thread_rng();↵→let mut lst: Vec<u32> = (0..20).map(|_| rng.gen_range(1..101)).collect();↵→println!("{:?}", lst);↵→lst.sort();↵→println!("{:?}", lst);↵→let even: Vec<_> = lst.iter().filter(|x| *x % 2 == 0).collect();↵→println!("{:?}", even);↵}`,
  `fn palindrome(s: &str) -> bool {↵→s.chars().eq(s.chars().rev())↵}↵fn main() {↵→let words = vec!["level", "world", "radar"];↵→let pal: Vec<_> = words.iter().filter(|w| palindrome(w)).collect();↵→println!("{:?}", pal);↵→let nums = vec![121, 12321, 123];↵→let pal_nums: Vec<_> = nums.iter().filter(|n| palindrome(&n.to_string())).collect();↵→println!("{:?}", pal_nums);↵}`,
  `use itertools::Itertools;↵fn main() {↵→let perms: Vec<_> = "abc".chars().permutations(3).map(|p| p.iter().collect::<String>()).collect();↵→println!("{:?}", perms);↵→let combs: Vec<_> = "wxyz".chars().combinations(2).map(|c| c.iter().collect::<String>()).collect();↵→println!("{:?}", combs);↵→let mut cycle = "AB".chars().cycle();↵→println!("{:?}", (0..10).map(|_| cycle.next().unwrap()).collect::<Vec<_>>());↵}`,
  `fn primes(n: usize) -> Vec<usize> {↵→let mut sieve = vec![true; n];↵→sieve[0] = false;↵→sieve[1] = false;↵→for i in 2..(n as f64).sqrt() as usize + 1 {↵→→if sieve[i] {↵→→→for j in (i*i..n).step_by(i) {↵→→→→sieve[j] = false;↵→→→}↵→→}↵→}↵→sieve.iter().enumerate().filter_map(|(i, &v)| if v { Some(i) } else { None }).collect()↵}↵fn main() {↵→println!("{:?}", primes(50));↵}`,
  `use chrono::prelude::*;↵fn main() {↵→let dt = Local::now();↵→println!("{}", dt);↵→println!("{}", dt.format("%Y-%m-%d %H:%M:%S"));↵→println!("{}", dt.date());↵→println!("{}", dt.time());↵→println!("{}", dt.weekday());↵→println!("{}", dt.iso_week());↵→println!("{}", dt.format("%+"));↵}`,
  `fn flatten<T: Clone>(lst: &Vec<Vec<T>>) -> Vec<T> {↵→lst.iter().flat_map(|x| x.clone()).collect()↵}↵fn main() {↵→let nested = vec![vec![1,2], vec![3,4,5], vec![6]];↵→println!("{:?}", flatten(&nested));↵}`,
  `use regex::Regex;↵fn main() {↵→let text = "The rain in Spain falls mainly in the plain.";↵→let re = Regex::new(r"\\bin\\w+").unwrap();↵→println!("{:?}", re.find_iter(text).map(|m| m.as_str()).collect::<Vec<_>>());↵→let re2 = Regex::new("ain").unwrap();↵→println!("{}", re2.replace_all(text, "***"));↵}`,
  `fn gcd(mut a: u32, mut b: u32) -> u32 {↵→while b != 0 {↵→→let t = b;↵→→b = a % b;↵→→a = t;↵→}↵→a↵}↵fn lcm(a: u32, b: u32) -> u32 {↵→a * b / gcd(a, b)↵}↵fn main() {↵→println!("{}", gcd(48, 18));↵→println!("{}", lcm(12, 15));↵→let nums = vec![(12,18),(7,5),(21,14)];↵→for (x,y) in nums {↵→→println!("{} {}", gcd(x,y), lcm(x,y));↵→}↵}`,
  `fn is_prime(n: u32) -> bool {↵→if n < 2 { return false; }↵→for i in 2..=((n as f64).sqrt() as u32) {↵→→if n % i == 0 { return false; }↵→}↵→true↵}↵fn main() {↵→println!("{:?}", (2..30).filter(|&x| is_prime(x)).collect::<Vec<_>>());↵}`,
  `fn main() {↵→let lst = vec![1,2,3,4,5];↵→println!("{}", lst.iter().product::<i32>());↵→println!("{}", lst.iter().sum::<i32>());↵→println!("{}", lst.iter().fold(0, |a, &b| a-b));↵→println!("{}", lst.iter().fold(1, |a, &b| a/b));↵→println!("{}", lst.iter().max().unwrap());↵→println!("{}", lst.iter().min().unwrap());↵}`,
  `fn reverse_words(s: &str) -> String {↵→s.split_whitespace().rev().collect::<Vec<_>>().join(" ")↵}↵fn main() {↵→println!("{}", reverse_words("hello world from rust"));↵→println!("{}", reverse_words("Copilot is awesome"));↵}`,
  `fn main() {↵→println!("{}", std::env::consts::OS);↵→println!("{:?}", std::env::args().collect::<Vec<_>>());↵→println!("{:?}", std::env::vars().collect::<Vec<_>>());↵→println!("{}", std::env::current_dir().unwrap().display());↵}`,
  `fn squares(n: usize) -> Vec<usize> {↵→(0..n).map(|x| x*x).collect()↵}↵fn main() {↵→println!("{:?}", squares(10));↵→println!("{:?}", squares(20).into_iter().filter(|x| x%2==0).collect::<Vec<_>>());↵→println!("{}", squares(5).iter().sum::<usize>());↵}`,
  `use std::fs;↵fn main() {↵→println!("{}", std::env::current_dir().unwrap().display());↵→println!("{:?}", fs::read_dir(".").unwrap().map(|r| r.unwrap().file_name()).collect::<Vec<_>>());↵→println!("{}", std::env::var("HOME").unwrap_or_default());↵}`,
  `fn unique(lst: Vec<i32>) -> Vec<i32> {↵→let mut s = std::collections::HashSet::new();↵→lst.into_iter().filter(|x| s.insert(*x)).collect()↵}↵fn main() {↵→let lst = vec![1,2,2,3,4,4,5,5,5];↵→println!("{:?}", unique(lst));↵}`,
  `use serde_json::json;↵fn main() {↵→let data = json!({"a":1,"b":2,"c":[3,4,5]});↵→let js = data.to_string();↵→println!("{}", js);↵→let parsed: serde_json::Value = serde_json::from_str(&js).unwrap();↵→println!("{:?}", parsed);↵}`,
  `fn flatten_map(d: &std::collections::HashMap<&str, serde_json::Value>, prefix: String) -> std::collections::HashMap<String, serde_json::Value> {↵→let mut out = std::collections::HashMap::new();↵→for (k, v) in d {↵→→match v {↵→→→serde_json::Value::Object(map) => {↵→→→→let sub = flatten_map(map, format!("{}{}.", prefix, k));↵→→→→out.extend(sub);↵→→→},↵→→→_ => {↵→→→→out.insert(format!("{}{}", prefix, k), v.clone());↵→→→}↵→→}↵→}↵→out↵}`,
  `fn main() {↵→println!("{}", ('a'..='z').collect::<String>());↵→println!("{}", ('A'..='Z').collect::<String>());↵→println!("{}", (0..=9).map(|x| x.to_string()).collect::<String>());↵}`,
  `fn transpose<T: Clone>(m: Vec<Vec<T>>) -> Vec<Vec<T>> {↵→if m.is_empty() { return vec![]; }↵→(0..m[0].len()).map(|i| m.iter().map(|row| row[i].clone()).collect()).collect()↵}↵fn main() {↵→let m = vec![vec![1,2,3],vec![4,5,6],vec![7,8,9]];↵→println!("{:?}", transpose(m));↵}`,
  `use std::time::{Instant, SystemTime};↵fn main() {↵→let start = Instant::now();↵→std::thread::sleep(std::time::Duration::from_millis(100));↵→println!("Elapsed: {:?}", start.elapsed());↵→println!("{:?}", SystemTime::now());↵}`,
  `fn merge(mut a: Vec<i32>, mut b: Vec<i32>) -> Vec<i32> {↵→a.append(&mut b);↵→a.sort();↵→a↵}↵fn main() {↵→println!("{:?}", merge(vec![1,3,5], vec![2,4,6]));↵}`,
  `fn all_even(lst: &[i32]) -> bool {↵→lst.iter().all(|x| x%2==0)↵}↵fn main() {↵→println!("{}", all_even(&[2,4,6,8]));↵→println!("{}", all_even(&[1,2,3]));↵}`,
  `fn chunk<T: Clone>(lst: &[T], n: usize) -> Vec<Vec<T>> {↵→lst.chunks(n).map(|c| c.to_vec()).collect()↵}↵fn main() {↵→println!("{:?}", chunk(&[1,2,3,4,5,6,7,8,9], 3));↵}`,
  `use sha2::{Sha256, Digest};↵fn main() {↵→let s = "hello world";↵→let mut hasher = Sha256::new();↵→hasher.update(s);↵→let result = hasher.finalize();↵→println!("{:x}", result);↵}`,
  `fn rotate<T: Clone>(lst: &[T], k: usize) -> Vec<T> {↵→let n = lst.len();↵→let k = k % n;↵→lst[k..].iter().chain(lst[..k].iter()).cloned().collect()↵}↵fn main() {↵→println!("{:?}", rotate(&[1,2,3,4,5], 2));↵}`,
  `use rand::Rng;↵fn main() {↵→let mut rng = rand::thread_rng();↵→println!("{:?}", (0..5).map(|_| rng.gen::<f64>()).collect::<Vec<_>>());↵→println!("{:?}", (0..5).map(|_| rng.gen_range(1..11)).collect::<Vec<_>>());↵}`,
  `fn is_anagram(a: &str, b: &str) -> bool {↵→let mut a: Vec<_> = a.chars().collect();↵→let mut b: Vec<_> = b.chars().collect();↵→a.sort();↵→b.sort();↵→a == b↵}↵fn main() {↵→println!("{}", is_anagram("listen", "silent"));↵}`,
  `fn main() {↵→let mut lst = vec![5,1,3,7,2];↵→lst.sort();↵→println!("{:?}", lst);↵→let idx = lst.binary_search(&3).unwrap_or(0);↵→println!("{}", idx);↵}`,
  `fn count_vowels(s: &str) -> usize {↵→s.chars().filter(|c| "aeiouAEIOU".contains(*c)).count()↵}↵fn main() {↵→println!("{}", count_vowels("Copilot"));↵→println!("{}", count_vowels("Python"));↵}`,
  `use std::collections::BinaryHeap;↵fn main() {↵→let mut heap = BinaryHeap::from(vec![5,1,3,7,2]);↵→println!("{:?}", heap.pop());↵→heap.push(4);↵→println!("{:?}", heap);↵}`,
  `fn run_length_encode(s: &str) -> Vec<(char, usize)> {↵→let mut res = vec![];↵→let mut chars = s.chars().peekable();↵→while let Some(c) = chars.next() {↵→→let mut count = 1;↵→→while chars.peek() == Some(&c) {↵→→→chars.next();↵→→→count += 1;↵→→}↵→→res.push((c, count));↵→}↵→res↵}↵fn main() {↵→println!("{:?}", run_length_encode("aaabbcaaa"));↵}`,
  `use std::collections::VecDeque;↵fn main() {↵→let mut q = VecDeque::from(vec![1,2,3]);↵→q.push_back(4);↵→q.push_front(0);↵→println!("{:?}", q);↵→q.pop_back();↵→q.pop_front();↵→println!("{:?}", q);↵}`,
  `fn pascal(n: usize) -> Vec<Vec<u32>> {↵→let mut res = vec![vec![1]];↵→for i in 1..n {↵→→let mut row = vec![1];↵→→for j in 1..i {↵→→→row.push(res[i-1][j-1]+res[i-1][j]);↵→→}↵→→row.push(1);↵→→res.push(row);↵→}↵→res↵}↵fn main() {↵→for row in pascal(7) {↵→→println!("{:?}", row);↵→}↵}`,
  `use csv::Writer;↵fn main() {↵→let mut wtr = Writer::from_path("test.csv").unwrap();↵→wtr.write_record(&["a","b","c"]).unwrap();↵→wtr.write_record(&["1","2","3"]).unwrap();↵→wtr.write_record(&["4","5","6"]).unwrap();↵→wtr.flush().unwrap();↵}`,
  `fn is_palindrome_num(n: u32) -> bool {↵→let s = n.to_string();↵→s == s.chars().rev().collect::<String>()↵}↵fn main() {↵→println!("{:?}", (100..200).filter(|&x| is_palindrome_num(x)).collect::<Vec<_>>());↵}`,
  `use uuid::Uuid;↵fn main() {↵→let u = Uuid::new_v4();↵→println!("{}", u);↵→println!("{}", u.to_simple());↵}`,
  `fn group_by_len(words: Vec<&str>) -> std::collections::HashMap<usize, Vec<&str>> {↵→let mut d = std::collections::HashMap::new();↵→for w in words {↵→→d.entry(w.len()).or_insert(vec![]).push(w);↵→}↵→d↵}↵fn main() {↵→let words = vec!["the","quick","brown","fox"];↵→println!("{:?}", group_by_len(words));↵}`,
  `use chrono::Datelike;↵fn main() {↵→let today = chrono::Local::today();↵→println!("{}", today.month());↵→println!("{}", today.weekday());↵→println!("{}", today.iso_week().week());↵}`,
  `fn is_sorted(lst: &[i32]) -> bool {↵→lst.windows(2).all(|w| w[0] <= w[1])↵}↵fn main() {↵→println!("{}", is_sorted(&[1,2,3,4]));↵→println!("{}", is_sorted(&[4,3,2,1]));↵}`,
  `use std::fs;↵fn main() {↵→fs::copy("test.csv", "test2.csv").unwrap();↵→let data = fs::read_to_string("test2.csv").unwrap();↵→println!("{}", data);↵→fs::rename("test2.csv", "test3.csv").unwrap();↵→let data2 = fs::read_to_string("test3.csv").unwrap();↵→println!("{}", data2);↵}`,
  `fn to_base(mut n: usize, b: usize) -> String {↵→let digits = "0123456789ABCDEF".chars().collect::<Vec<_>>();↵→let mut res = String::new();↵→if n == 0 { return "0".to_string(); }↵→while n > 0 {↵→→res.insert(0, digits[n%b]);↵→→n /= b;↵→}↵→res↵}↵fn main() {↵→println!("{}", to_base(255,2));↵→println!("{}", to_base(255,16));↵}`,
  `use zip::write::FileOptions;↵use std::fs::File;↵use std::io::Write;↵fn main() {↵→let path = "test.zip";↵→let file = File::create(path).unwrap();↵→let mut zip = zip::ZipWriter::new(file);↵→zip.start_file("test.csv", FileOptions::default()).unwrap();↵→zip.write_all(b"hello").unwrap();↵→zip.finish().unwrap();↵}`,
  `fn freq(s: &str) -> std::collections::HashMap<char, usize> {↵→let mut d = std::collections::HashMap::new();↵→for c in s.chars() {↵→→*d.entry(c).or_insert(0) += 1;↵→}↵→d↵}↵fn main() {↵→println!("{:?}", freq("abracadabra"));↵}`,
  `use std::net::ToSocketAddrs;↵fn main() {↵→let host = "localhost:80";↵→let addrs: Vec<_> = host.to_socket_addrs().unwrap().collect();↵→println!("{:?}", addrs);↵}`,
  `fn spiral(n: usize) -> Vec<Vec<usize>> {↵→let mut a = vec![vec![0;n];n];↵→let (mut x, mut y, mut dx, mut dy) = (0,0,0,1);↵→for i in 1..=n*n {↵→→a[x][y]=i;↵→→if a[(x+dx)%n][(y+dy)%n]!=0 {↵→→→let t=dx;↵→→→dx=dy;↵→→→dy=-t;↵→→}↵→→x+=dx;↵→→y+=dy;↵→}↵→a↵}↵fn main() {↵→for row in spiral(5) {↵→→println!("{:?}", row);↵→}↵}`,
  `use tempfile::NamedTempFile;↵use std::io::Write;↵fn main() {↵→let mut f = NamedTempFile::new().unwrap();↵→f.write_all(b"hello world").unwrap();↵→println!("{}", f.path().display());↵}`,
  `fn is_subsequence(a: &str, b: &str) -> bool {↵→let mut ai = 0;↵→let a = a.chars().collect::<Vec<_>>();↵→for c in b.chars() {↵→→if ai < a.len() && a[ai] == c { ai += 1; }↵→}↵→ai == a.len()↵}↵fn main() {↵→println!("{}", is_subsequence("abc","aabbcc"));↵}`,
  `fn main() {↵→let d = vec![("a",1),("b",vec![2,3]),("c",4)];↵→println!("{:?}", d);↵→let arr: Vec<_> = (0..5).map(|i| ("x",i,"y",i*i)).collect();↵→println!("{:?}", arr);↵}`,
];
