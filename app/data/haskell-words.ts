export const HASKELL_WORDS = [
  `module Main where↵main :: IO ()↵main = do↵→putStrLn "Hello, World!"↵→let xs = [1..10]↵→print $ map (\\x -> x * x) xs↵→let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)↵→print $ take 10 fibs↵→let fact n = if n == 0 then 1 else n * fact (n - 1)↵→print $ fact 5`,
  `import Data.List↵primes :: [Int]↵primes = sieve [2..]↵→where↵→→sieve (p:xs) = p : sieve [x | x <- xs, x \`mod\` p /= 0]↵main :: IO ()↵main = print $ take 20 primes↵sumSquares :: Int -> Int↵sumSquares n = sum $ map (\\x -> x*x) [1..n]↵`,
  `data Tree a = Leaf a | Node (Tree a) (Tree a)↵size :: Tree a -> Int↵size (Leaf _) = 1↵size (Node l r) = size l + size r↵depth :: Tree a -> Int↵depth (Leaf _) = 1↵depth (Node l r) = 1 + max (depth l) (depth r)↵main = print $ depth (Node (Leaf 1) (Node (Leaf 2) (Leaf 3)))`,
  `fizzbuzz :: Int -> String↵fizzbuzz n↵→| n \`mod\` 15 == 0 = "FizzBuzz"↵→| n \`mod\` 3 == 0 = "Fizz"↵→| n \`mod\` 5 == 0 = "Buzz"↵→| otherwise = show n↵main = mapM_ (putStrLn . fizzbuzz) [1..30]↵sumFB = sum [x | x <- [1..100], fizzbuzz x == "FizzBuzz"]`,
  `quicksort :: Ord a => [a] -> [a]↵quicksort [] = []↵quicksort (x:xs) = quicksort [y | y <- xs, y < x] ++ [x] ++ quicksort [y | y <- xs, y >= x]↵main = print $ quicksort [3,1,4,1,5,9,2,6,5,3,5]↵double = map (\\x -> x*2) [1..10]↵`,
  `reverseWords :: String -> String↵reverseWords = unwords . map reverse . words↵main = do↵→let s = "Haskell is fun"↵→putStrLn $ reverseWords s↵→print $ map (\\x -> x + 1) [1,2,3,4]↵→print $ filter even [1..20]↵→print $ foldl (+) 0 [1..100]`,
  `factorial :: Integer -> Integer↵factorial 0 = 1↵factorial n = n * factorial (n - 1)↵main = do↵→print $ factorial 10↵→let xs = [1..5]↵→print $ scanl1 (*) xs↵→print $ zip xs (map factorial xs)↵→print $ all (>0) xs`,
  `palindrome :: Eq a -> [a] -> Bool↵palindrome xs = xs == reverse xs↵main = do↵→print $ palindrome "racecar"↵→print $ palindrome [1,2,3,2,1]↵→print $ palindrome [1,2,3]↵→let test = ["madam","hello","level"]↵→print $ map palindrome test`,
  `collatz :: Int -> [Int]↵collatz 1 = [1]↵collatz n↵→| even n = n : collatz (n \`div\` 2)↵→| otherwise = n : collatz (3*n+1)↵main = do↵→print $ collatz 13↵→print $ length $ collatz 27↵→print $ maximum $ collatz 19↵→print $ take 10 $ collatz 97`,
  `isPrime :: Int -> Bool↵isPrime n = n > 1 && all ((/=0) . mod n) [2..floor $ sqrt $ fromIntegral n]↵main = do↵→print $ filter isPrime [1..50]↵→print $ take 10 $ filter isPrime [100..]↵→print $ map isPrime [2,3,4,5,6,7,8,9,10]`,
  `fib :: Int -> Int↵fib 0 = 0↵fib 1 = 1↵fib n = fib (n-1) + fib (n-2)↵main = do↵→print $ map fib [0..10]↵→print $ zip [0..10] (map fib [0..10])↵→print $ sum $ map fib [0..5]↵→print $ fib 15`,
  `gcd' :: Int -> Int -> Int↵gcd' a 0 = a↵gcd' a b = gcd' b (a \`mod\` b)↵main = do↵→print $ gcd' 54 24↵→print $ gcd' 1071 462↵→print $ map (gcd' 42) [1..10]↵→print $ foldl gcd' 0 [12,24,36,48]`,
  `lcm' :: Int -> Int -> Int↵lcm' a b = abs (a * b) \`div\` gcd a b↵main = do↵→print $ lcm' 12 18↵→print $ lcm' 21 6↵→print $ map (lcm' 15) [1..10]↵→print $ foldl lcm' 1 [2,3,4,5]`,
  `sumDigits :: Int -> Int↵sumDigits 0 = 0↵sumDigits n = n \`mod\` 10 + sumDigits (n \`div\` 10)↵main = do↵→print $ sumDigits 12345↵→print $ map sumDigits [10,20,30,40]↵→print $ filter ((==9) . sumDigits) [1..100]`,
  `triangle :: Int -> [[Int]]↵triangle n = [ [1..x] | x <- [1..n] ]↵main = do↵→print $ triangle 5↵→mapM_ print $ triangle 4↵→print $ concat $ triangle 3↵→print $ length $ triangle 10`,
  `powerset :: [a] -> [[a]]↵powerset [] = [[]]↵powerset (x:xs) = let ps = powerset xs in ps ++ map (x:) ps↵main = do↵→print $ powerset [1,2,3]↵→print $ length $ powerset [1..5]↵→print $ filter ((==2) . length) $ powerset [1,2,3]`,
  `zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]↵zipWith' _ [] _ = []↵zipWith' _ _ [] = []↵zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys↵main = do↵→print $ zipWith' (+) [1,2,3] [4,5,6]↵→print $ zipWith' (*) [1,2,3] [7,8,9]`,
  `takeWhile' :: (a -> Bool) -> [a] -> [a]↵takeWhile' _ [] = []↵takeWhile' p (x:xs)↵→| p x = x : takeWhile' p xs↵→| otherwise = []↵main = do↵→print $ takeWhile' (<5) [1..10]↵→print $ takeWhile' even [2,4,6,7,8]`,
  `dropWhile' :: (a -> Bool) -> [a] -> [a]↵dropWhile' _ [] = []↵dropWhile' p (x:xs)↵→| p x = dropWhile' p xs↵→| otherwise = x:xs↵main = do↵→print $ dropWhile' (<5) [1..10]↵→print $ dropWhile' even [2,4,6,7,8]`,
  `partition' :: (a -> Bool) -> [a] -> ([a],[a])↵partition' _ [] = ([],[])↵partition' p (x:xs) = let (ts,fs) = partition' p xs in if p x then (x:ts,fs) else (ts,x:fs)↵main = print $ partition' even [1..10]`,
  `countIf :: (a -> Bool) -> [a] -> Int↵countIf p = length . filter p↵main = do↵→print $ countIf even [1..20]↵→print $ countIf (>5) [1..10]↵→print $ countIf (\\x -> x \`mod\` 3 == 0) [1..30]`,
  `allPairs :: [a] -> [b] -> [(a,b)]↵allPairs xs ys = [(x,y) | x <- xs, y <- ys]↵main = do↵→print $ allPairs [1,2] ['a','b']↵→print $ allPairs [True,False] [0,1]↵→print $ length $ allPairs [1..5] [1..5]`,
  `cartesianProduct :: [[a]] -> [[a]]↵cartesianProduct [] = [[]]↵cartesianProduct (xs:xss) = [ x:ys | x <- xs, ys <- cartesianProduct xss ]↵main = print $ cartesianProduct [[1,2],[3,4],[5,6]]`,
  `rotate :: Int -> [a] -> [a]↵rotate n xs = take (length xs) $ drop n $ cycle xs↵main = do↵→print $ rotate 2 [1,2,3,4,5]↵→print $ rotate 3 "haskell"↵→print $ rotate 0 [1,2,3]`,
  `groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]↵groupBy' _ [] = []↵groupBy' eq (x:xs) = (x:ys) : groupBy' eq zs↵→where (ys,zs) = span (eq x) xs↵main = print $ groupBy' (\\a b -> a == b) [1,1,2,2,2,3,1,1]`,
  `scanl' :: (b -> a -> b) -> b -> [a] -> [b]↵scanl' _ q [] = [q]↵scanl' f q (x:xs) = q : scanl' f (f q x) xs↵main = print $ scanl' (+) 0 [1..10]`,
  `repeat' :: a -> [a]↵repeat' x = xs where xs = x : xs↵main = print $ take 10 $ repeat' 7↵cycle' :: [a] -> [a]↵cycle' xs = xs ++ cycle' xs↵main2 = print $ take 8 $ cycle' [1,2,3]`,
  `tails' :: [a] -> [[a]]↵tails' [] = [[]]↵tails' xs@(_:xs') = xs : tails' xs'↵main = print $ tails' [1,2,3,4]↵inits' :: [a] -> [[a]]↵inits' [] = [[]]↵inits' xs = inits' (init xs) ++ [xs]↵main2 = print $ inits' [1,2,3,4]`,
  `nub' :: Eq a -> [a] -> [a]↵nub' [] = []↵nub' (x:xs) = x : nub' (filter (/= x) xs)↵main = print $ nub' [1,2,2,3,4,4,5,1,2]`,
  `elemIndices' :: Eq a -> a -> [a] -> [Int]↵elemIndices' y xs = [i | (x,i) <- zip xs [0..], x == y]↵main = print $ elemIndices' 2 [1,2,3,2,4,2,5]`,
  `transpose' :: [[a]] -> [[a]]↵transpose' ([]:_) = []↵transpose' x = map head x : transpose' (map tail x)↵main = print $ transpose' [[1,2,3],[4,5,6],[7,8,9]]`,
  `chunksOf :: Int -> [a] -> [[a]]↵chunksOf _ [] = []↵chunksOf n xs = take n xs : chunksOf n (drop n xs)↵main = print $ chunksOf 3 [1..10]`,
  `isSorted :: Ord a -> [a] -> Bool↵isSorted [] = True↵isSorted [_] = True↵isSorted (x:y:xs) = x <= y && isSorted (y:xs)↵main = print $ isSorted [1,2,3,4,5]↵main2 = print $ isSorted [5,4,3,2,1]`,
  `merge :: Ord a -> [a] -> [a] -> [a]↵merge xs [] = xs↵merge [] ys = ys↵merge (x:xs) (y:ys)↵→| x < y = x : merge xs (y:ys)↵→| otherwise = y : merge (x:xs) ys↵main = print $ merge [1,3,5] [2,4,6]`,
  `interleave :: [a] -> [a] -> [a]↵interleave [] ys = ys↵interleave xs [] = xs↵interleave (x:xs) (y:ys) = x : y : interleave xs ys↵main = print $ interleave [1,3,5] [2,4,6]`,
  `permutations' :: [a] -> [[a]]↵permutations' [] = [[]]↵permutations' xs = [y:zs | (y,ys) <- select xs, zs <- permutations' ys]↵→where select [] = []↵→→select (y:ys) = (y,ys) : [(x,y:xs) | (x,xs) <- select ys]↵main = print $ permutations' [1,2,3]`,
  `subsequences' :: [a] -> [[a]]↵subsequences' [] = [[]]↵subsequences' (x:xs) = let ss = subsequences' xs in ss ++ map (x:) ss↵main = print $ subsequences' [1,2,3]`,
  `sumPairs :: [Int] -> [Int]↵sumPairs xs = [x+y | (x,y) <- zip xs (tail xs)]↵main = print $ sumPairs [1,2,3,4,5]`,
  `dotProduct :: [Int] -> [Int] -> Int↵dotProduct xs ys = sum $ zipWith (*) xs ys↵main = print $ dotProduct [1,2,3] [4,5,6]`,
  `isPalindrome :: Eq a -> [a] -> Bool↵isPalindrome xs = xs == reverse xs↵main = print $ isPalindrome "hannah"↵main2 = print $ isPalindrome [1,2,3,2,1]`,
  `flatten :: [[a]] -> [a]↵flatten = foldr (++) []↵main = print $ flatten [[1,2],[3,4],[5,6]]`,
  `countElem :: Eq a -> a -> [a] -> Int↵countElem x = length . filter (==x)↵main = print $ countElem 2 [1,2,3,2,4,2,5]`,
  `replicate' :: Int -> a -> [a]↵replicate' n x = take n $ repeat x↵main = print $ replicate' 5 'a'↵main2 = print $ replicate' 3 7`,
  `everyOther :: [a] -> [a]↵everyOther [] = []↵everyOther (x:xs) = x : skip xs↵→where skip [] = []↵→→skip (_:ys) = everyOther ys↵main = print $ everyOther [1..10]`,
  `sumMatrix :: [[Int]] -> Int↵sumMatrix = sum . map sum↵main = print $ sumMatrix [[1,2,3],[4,5,6],[7,8,9]]`,
  `diagonal :: [[a]] -> [a]↵diagonal m = [row !! i | (row,i) <- zip m [0..], i < length row]↵main = print $ diagonal [[1,2,3],[4,5,6],[7,8,9]]`,
  `zipN :: [[a]] -> [[a]]↵zipN = foldr (zipWith (:)) (repeat [])↵main = print $ zipN [[1,2,3],[4,5,6],[7,8,9]]`,
  `sumOfSquares :: [Int] -> Int↵sumOfSquares = sum . map (\\x -> x*x)↵main = print $ sumOfSquares [1..10]`,
  `compose :: [a -> a] -> a -> a↵compose = foldr (.) id↵main = print $ compose [(+1),(*2),subtract 3] 10`,
];
